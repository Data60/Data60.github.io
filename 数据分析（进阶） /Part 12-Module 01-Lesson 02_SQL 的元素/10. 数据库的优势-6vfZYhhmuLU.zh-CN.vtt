WEBVTT
Kind: captions
Language: zh-CN

00:00:00.370 --> 00:00:04.580
在听到 order by, limit 以及 Offset 这类 SQL 功能时

00:00:04.580 --> 00:00:09.140
很多人都会问一个问题 为什么要在数据库中执行这些操作？

00:00:09.140 --> 00:00:11.680
我已经知道怎么在 Python 中对一个列表进行排序了

00:00:11.680 --> 00:00:13.510
我也知道怎么做切片

00:00:13.510 --> 00:00:16.860
为什么不干脆将未排序的数据交给代码

00:00:16.860 --> 00:00:18.220
然后在那里执行操作呢？

00:00:18.220 --> 00:00:21.866
count 返回的结果和 length 一样 多得吓人

00:00:21.866 --> 00:00:24.852
limit 100 offset 10 返回的结果太多了

00:00:24.852 --> 00:00:30.470
就好像是从结果列表中 选取元素 10 至元素 110 一样

00:00:30.470 --> 00:00:35.430
对列进行排序 会返回非常多的结果 就像根据复杂的关键字

00:00:35.430 --> 00:00:38.968
进行排序一样 但有几个很大的不同之处

00:00:38.968 --> 00:00:42.080
速度和占用的空间

00:00:42.080 --> 00:00:45.830
数据库在执行这些操作时往往比 Python 快得多

00:00:45.830 --> 00:00:48.410
尤其是当你碰到的表格 合并了多个表格

00:00:48.410 --> 00:00:51.120
有很多行或者复杂的列时

00:00:51.120 --> 00:00:54.350
你很容易就会得到一个几百万行的表格

00:00:54.350 --> 00:00:57.830
在 Python 中对一百万个条目进行排序 大约耗时一秒左右

00:00:57.830 --> 00:01:01.280
如果你写的是一个网页应用 你的用户

00:01:01.280 --> 00:01:03.410
盯着浏览器看一秒钟 就会觉得奇怪 为何你的应用

00:01:03.410 --> 00:01:07.470
这么慢 而且在加载时还会占用内存

00:01:07.470 --> 00:01:11.510
相比之下 数据库执行这些操作时往往快得多

00:01:11.510 --> 00:01:14.600
你可以使用很多技巧让它更快一些

00:01:14.600 --> 00:01:16.410
一个很重要的技巧就是索引

00:01:16.410 --> 00:01:18.850
在本课中我们不会直接讨论索引

00:01:18.850 --> 00:01:21.610
但之后我们会提到如何使用它

00:01:21.610 --> 00:01:25.130
在任何情况下 在数据库 而不是在 Python 中

00:01:25.130 --> 00:01:28.220
执行限制和聚合操作都是很棒的做法

00:01:28.220 --> 00:01:29.290
所以 让我们更多地执行这些操作吧

