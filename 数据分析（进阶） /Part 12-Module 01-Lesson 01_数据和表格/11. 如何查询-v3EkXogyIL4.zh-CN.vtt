WEBVTT
Kind: captions
Language: zh-CN

00:00:00.360 --> 00:00:03.110
现在 我们已经学习了一些可以存储到数据库表中的

00:00:03.110 --> 00:00:07.230
信息类型 让我们来了解下代码是如何与数据库通信的

00:00:07.230 --> 00:00:10.630
代码通过发送一条查询语句从数据库中获取数据 

00:00:10.630 --> 00:00:13.860
作为回应 数据库将

00:00:13.860 --> 00:00:18.480
我们需要的数据作为新表发送回来

00:00:18.480 --> 00:00:22.440
根据我们所处环境的不同 代码可能会通过

00:00:22.440 --> 00:00:24.910
网络与数据库通信

00:00:24.910 --> 00:00:28.800
或者可能只是调用一个保存在本地磁盘上的库

00:00:28.800 --> 00:00:31.110
这些设计细节在后面会很重要 

00:00:31.110 --> 00:00:33.030
但现在 我们实际上可以忽略它们

00:00:33.030 --> 00:00:37.770
不论执行什么操作 数据库的基本原理都是相同的

00:00:37.770 --> 00:00:40.830
因此 让我们看看在 SQL 中针对一个实际的数据库

00:00:40.830 --> 00:00:42.290
进行查询的情况

00:00:42.290 --> 00:00:45.790
现在先不要担心语法 我们会在下节课学习

00:00:45.790 --> 00:00:48.140
好的 这里是我们以前见过的一个查询语句

00:00:48.140 --> 00:00:52.590
select food from diet where species = 'orangutan'

00:00:52.590 --> 00:00:54.020
我们运行这条语句后 得到这个结果

00:00:54.020 --> 00:00:57.750
需要注意的是 结果是一张表

00:00:57.750 --> 00:01:01.430
它有两行 确切的说表头下面有两行

00:01:01.430 --> 00:01:04.050
这个表有一列 就是我们要得到的食物的列

00:01:04.050 --> 00:01:08.530
因此针对一个数据库运行查询并不像

00:01:08.530 --> 00:01:10.600
从一个函数返回一个单一的值 而更像是返回一个列表

00:01:10.600 --> 00:01:12.780
即使可能只有一个元素

00:01:12.780 --> 00:01:17.530
实际上 即使我们让数据库返回2加2的结果 就像这样

00:01:17.530 --> 00:01:20.500
答案仍然是一个表 包含一行和一列

00:01:21.530 --> 00:01:26.025
如果我们让数据库同时返回三个算术问题的答案

00:01:26.025 --> 00:01:29.433
我们还是会得到一个表 包含一行和三列

00:01:29.433 --> 00:01:33.328
每一列都给出一个答案

00:01:33.328 --> 00:01:36.514
你或许已经注意到 这些列的名称与众不同

00:01:36.514 --> 00:01:39.580
它们全都是 ?column? 

00:01:39.580 --> 00:01:44.710
如果我们想给它们更具描述性的名称 我们可以使用 sum

00:01:44.710 --> 00:01:49.660
我们得到一个一行一列的表

00:01:49.660 --> 00:01:52.720
但现在 列有了一个更具描述性的名字 sum

00:01:52.720 --> 00:01:54.160
而不是 ?column?

