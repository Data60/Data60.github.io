WEBVTT
Kind: captions
Language: zh-CN

00:00:00.360 --> 00:00:04.220
很多人学习 SQL 时 会对这些内容多少有点惊讶 

00:00:04.220 --> 00:00:08.630
到目前为止 每当你完成一个 select  你已从一个表格或

00:00:08.630 --> 00:00:10.340
几个连接表格中进行了选择 

00:00:10.340 --> 00:00:12.940
你也可以从其他内容中选择 

00:00:12.940 --> 00:00:15.580
即选择查询的结果 

00:00:15.580 --> 00:00:19.120
这种形式被称为子查询 有时也称之为 subselect（子查询） 

00:00:20.650 --> 00:00:23.310
你是否还记得 我在第一课中说过

00:00:23.310 --> 00:00:25.350
查询结果始终为一个表格？

00:00:25.350 --> 00:00:26.650
这就是原因 

00:00:26.650 --> 00:00:30.000
由于查询结果是个表格  所以你可以通过连接、

00:00:30.000 --> 00:00:32.409
聚合表格等方式进行选择 

00:00:32.409 --> 00:00:36.130
这里有一个表格 其中列出了 麋鹿桌上足球的球员及其所在球队 

00:00:36.130 --> 00:00:39.180
以及上个赛季 进球点数 

00:00:39.180 --> 00:00:43.140
这里的查询将找出 每个球队中

00:00:43.140 --> 00:00:44.410
进球最多的球员 

00:00:44.410 --> 00:00:49.870
这个查询使用 max 聚合函数  group by team 来找出最高分 

00:00:49.870 --> 00:00:52.910
但是 假设我们想知道

00:00:52.910 --> 00:00:54.930
最高分的平均分是多少 

00:00:54.930 --> 00:01:00.490
为此 我们可以将这整个查询 插入另一个查询中 

00:01:00.490 --> 00:01:05.700
这样 外部的查询 将给出内部查询结果的平均数 

00:01:05.700 --> 00:01:10.830
SQL 语法要求我们为 子查询结果表格命名 即此处的 maxes 

00:01:10.830 --> 00:01:15.743
尽管我们并不会在查询中的 任何位置实际使用该单词 

00:01:15.743 --> 00:01:17.111
只是需要那么做 

00:01:17.111 --> 00:01:19.853
你也可以通过多种方法 使用子查询 

00:01:19.853 --> 00:01:23.720
当然这不是本课程的内容  但会非常有用 

00:01:23.720 --> 00:01:28.100
你可以读一下其他用例  讲师笔记中链接的

00:01:28.100 --> 00:01:31.010
where 子句和 PostgreSQL 文档中 中的子查询操作 

